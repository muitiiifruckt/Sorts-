/******************************************************************************
 
Welcome to GDB Online.
GDB online is an online compiler and debugger tool for C, C++, Python, Java, PHP, Ruby, Perl,
C#, VB, Swift, Pascal, Fortran, Haskell, Objective-C, Assembly, HTML, CSS, JS, SQLite, Prolog.
Code, Compile, Run and Debug online from anywhere in world.
 
*******************************************************************************/
#include <iostream>
#include <stack>
#include <algorithm>
 
using namespace std;
 
// работа с бинарными деревьями сортировки
class Tree
{
    // структура одного узла бинарного дерева (два потомка)
  struct Node
  {
        int info;
        Node* left; // ссылка на левый потомок - туда помещаются элементы, меньшие info
        Node* right; // ссылка на правый потомок - туда помещаются элементы, большие или равные info
        Node (int info)
        {
            this->info=info;
            left=right=NULL;   // создаются только листовые узлы дерева - узлы, у которых нет потомков
        }
  };
    // корень дерева
    Node* main_root;
    
    public:
    
    Tree();
    ~Tree();
    // нерекурсивный вариант функции добавления элемента в дерево
    void Add_1(int info);
    // функция-адаптер для рекурсивного варианта функции добавления элемента в дерево
    void Add_2(int info);
    // функция-адаптер для рекурсивного варианта функции печати элементов дерева
    void Print_2();
    // нерекурсивная функция печати элементов дерева
    void Print_1();
    // функция-адаптер для удаления узла дерево по значению
    void Remove(int info);
    // функция получения глубины дерева
    int Depth();
    // функция получения максимального четного элемента в дереве
    int MaxEven();
    private:
    // рекурсивные функции являются private-функциями, так как они по сути реализуют алгоритм и объект им нужен как хранилище данных
    // кроме того, параметры рекурсивной функции (ссылка на корень поддерева) фактически нарушают инкаплусяцию в случае видимости извне
    // рекурсивная функция добавления элемента в дерево (поддерево) с корнем root
    void Add_2(int info, Node*& root);
    // рекурсивная функция печати элеметов дерева
    void Print_2(Node* root);
    // рекурсивная функция удаления всех узлов дерева
    void Destroy(Node* root);
    // рекурсивная функиця удаления узла по заданному значению из дерева
    void Remove(int info, Node*& root);
    // рекурсивная функция получения глубины дерева
    int Depth(Node* root);
    // рекурсивная функция получения максимального четного элемента дерева
    bool MaxEven(Node* root, int& max);
};
 
// функция-адаптер для получения максимального четного элемента
int Tree::MaxEven()
{
    int max;
    // рекурсивная функция будет вовзращать флаг совершения операции, в параметр max заносится найденное значение
    // если операция удалась, то возвращается значение переменной max
    if(MaxEven(main_root,max)==true)
        return max;
    // результат не получен, если четных элементов нет - генерируем исключение, так как результат вернуть нельзя
    throw 1;
}
 
// рекурсивный алгоритм получения максимального четного элемента
bool Tree::MaxEven(Node* root, int& max)
{
    // в пустом дереве четных элементов нет - возвращаем флаг, говорящий о том, что не нашли нужного элемента
    if(root==NULL) return false;
    // пробуем искать в правом поддереве - там большие значения
    if (MaxEven(root->right,max))
        // если нашли, то это и есть максимальный элемент, он уже занечен в параметр max, так как он передан по ссылке
        return true;
    // если в правом поддереве не нашли, то проверяем корень
    if(root->info%2==0) 
    {
        // если в корне четный элемент, он и есть max - заносим его в переменную max для возврата результата
        max=root->info;
        return true;
    }
    // если в корне тоже нечетное значение, то все зависит от результата выполнения операции для левого поддерева
    return MaxEven(root->left,max);    
}
 
// функция-адаптер для получения глубины дерева
int Tree::Depth()
{
    if (main_root==NULL) 
        return 0;
    return Depth(main_root);
}
 
// рекурсивная функция получения глубины дерева
int Tree::Depth(Node* root)
{
     //если дерево пустое, то глубина 0
    if (root==NULL) 
        return 0;
    // получаем глубину левого и правого поддеревьев
    // результатом является максимум из глубин двух поддеревьев +1 (учет самого корневого узла)  
    return 1+max(Depth(root->left),Depth(root->right));
}
 
// функиця-адаптер для рекурсивной функции удаления элемента из дерева
void Tree::Remove(int info)
{
    Remove(info,main_root);
}
 
// рекурсивная функция удаления элемента из дерева    
void Tree::Remove(int info, Node*& root)
{
    // удаление из пустого поддерева не производится
    if(root==NULL) return;
    // проверка - найден ли удаляемый узел
    if(root->info==info)
    {
        Node* help=root;
        // если удаляемый узел не имеет левого потомка,
        // можно на его место подставить правое поддерево
        if(root->left==NULL)
        {
            root=root->right;
            delete help;
        }
        else
            // если удаляемый узел  не имеет правого потомка,
            // можно на его место подставить левое поддерево
            if(root->right==NULL)
            {
                root=root->left;
                delete help;
            }
            else
            {
                // удаляемый узел имеет обоих потомков
                // смещаемся на правого потомка
                Node* u=root->right;
                if(u->left==NULL)
                {
                    // если левого потомка не будет,
                    // можно узел u подставить на место root
                    // подцепляем левое поддерево и меняем корень поддерева
                    u->left=root->left;
                    root=u;
                    delete help;
                }
                else
                {
                    // если есть оба потомка, требуется найти самого левого потомка в правом поддереве
                    //cur2 - для поиска самого левого потомка, cur1 - его родитель
                    Node* cur1=u, *cur2=u->left;
                    while(cur2->left!=NULL)
                    {
                        cur1=cur1->left;
                        cur2=cur2->left;
                    }
                    // удаляем найденный крайний узел
                    // перемещаем значение из удаляемого узла в root
                    root->info=cur2->info;
                    // перемещаем правого потомка
                    cur1->left=cur2->right;
                    delete cur2;
                }
            }
    }
    else
        // требуется удалить элемент из того поддерева, в котором элемент находится
        if(root->info>info)
            Remove(info,root->left);
        else
            Remove(info,root->right);
}
 
// конструктор создает пустое дерево
Tree::Tree()
{
    main_root=NULL;
}
 
Tree::~Tree()
{
    Destroy(main_root);
}
 
// рекурсивная функция удаления элементов поддерева
void Tree::Destroy(Node* root)
{
    // уничтожаем, если дерево есть
    if (root!=NULL)
    {
        //рекурсивный вызов левого, а затем и правого поддеревьем
        Destroy(root->left);
        Destroy(root->right);
        // после уничтожения потомков можно удалить и сам корневой узел
        delete root;
    }
}
 
// нерекурсивный вариант обхода элементов дерева для печати
void Tree::Print_1()
{
    // для возврата на верхние узлы дерева требуется стек
    stack<Node*> s;
    // начинаем проход с корневого узла дерева
    Node* cur=main_root;
    // пока не кончатся узлы, осуществляем перебор
    // узлы закончатся, когда дойдем до конца ветви и некуда будет возвращаться (стек окажется пустым)
    while(!s.empty() || cur!=NULL)
    {
        // двигаемся по самой левой ветви до ее конца
        while(cur!=NULL)
        {
            // каждый пройденный узел помещается в стек
            s.push(cur); 
            // сдвигаемся дальше по самой левой ветви
            cur=cur->left;
        }
        // дошли до конца ветви, требуется вернуться на предыдущий узел,
        // чтобы переместиться на правого потомка
        // считываем последний пройденный узел из стека
        cur=s.top(); s.pop();
        // печать информации из узла
        cout<<cur->info<<" ";
        // передвижение на правого потомка - его обработкой заканчивается обработка поддерева
        cur=cur->right;
    }
    cout<<endl;
}
 
//функция-адаптер для рекурсивного варианта функции печати элементов дерева
void Tree::Print_2()
{
    // если дерево пустое, печатаем сообщение
    if (main_root==NULL)
        cout<<"Дерево пусто"<<endl;
    else
        // для непустого дерева вызываем рекурсивную функцию для всего дерева (передаем корень всего дерева)
        Print_2(main_root);
}
 
// рекурсивная функция печати элементов поддерева с корнем root (обход ЛКП) 
void Tree::Print_2(Node* root)
{
    // явный случай - пустое дерево не печатаем
    if (root==NULL) return;
    // сначала печатаем левое поддерево
    Print_2(root->left);
    // печатаем значение в корне поддерева
    cout<<(root->info)<<" ";
    // печатаем правое поддерево
    Print_2(root->right);
}
 
// функция-адаптер для алгоритма рекурсивного добавления элемента в дерево
void Tree::Add_2(int info)
{
    // нерекурсивный вызов
    Add_2(info, main_root);
}
 
// рекурсивная функция добавления элемента в поддерево с корнем root  (передается по ссылке, чтобы можно было новый узел сохранить)
void Tree::Add_2(int info, Node*& root)
{
    // если поддерево пустое, создаем единственный узел (адрес сохранится в переменной, ссылка на которую передана в качестве параметра)
    if(root==NULL)
    {
        root = new Node(info); return;
    }
    // если значение должно быть в левом поддереве
    if(root->info > info)
        // добавляем значение в левое поддерево
        Add_2(info, root->left);
    else
        // добавляем значение в правое поддерево
        Add_2(info, root->right);
}
 
// нерекурсивный вариант функции добавления элемента в дерево 
void Tree::Add_1(int info)
{
    // в пустое дерево добавляется единственный узел
    if(main_root==NULL)
    {
        main_root = new Node(info); return;
    }
    //если дерево не пустое, требуется найти место встави, начиная с корня, пройдя по одной ветви дерева 
    Node* cur=main_root;
    // движение по дереву будем проводить до получения места вставки - количество шагов в этом случае неизвестно
    while(true)
    {
        if(cur->info > info)
            // добавление производится в левое поддерево
            if(cur->left!=NULL)
                // если левое поддерево не пусто, то сдвигаемся на корень левого поддерева
                cur=cur->left;
            else
            {
                // если левое поддерево пусто, найдено место вставки
                // создается новый элемент и подцепляется в виде левого потомка
                cur->left=new Node(info); return;
            }
        else
            // добавление производится в правое поддерево
            if(cur->right!=NULL)
                // если правое поддерево не пусто, то сдвигаемся на корень правого поддерева
                cur=cur->right;
            else
            {
                // если правое поддерево пусто, найдено место вставки
                // создается новый элемент и подцепляется в виде правого потомка
                cur->right=new Node(info); return;
            }
    }
}
 
 
int main()
{
    Tree tree;
    int a[]={7,3,9,6,8,1,2,4,5};
    for(int i=0;i<9; i++)
        tree.Add_2(a[i]);
    tree.Print_1();
    cout<<endl;
    cout<<tree.Depth()<<endl;
    cout<<tree.MaxEven()<<endl;
   // tree.Remove(3);
//    tree.Print_2();
   
    return 0;
}
 
 
 


